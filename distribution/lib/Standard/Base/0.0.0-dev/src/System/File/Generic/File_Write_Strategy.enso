## PRIVATE
   Specifies the logic for handling writing files with options like `Existing_File_Behavior` and dry run.
type File_Write_Strategy
    ## PRIVATE
       Each of the `write_` strategies takes the file as a first argument, an
       action taking an `Output_Stream` as a second argument and should run this
       action against the output stream opened for the file and return its
       result.

       The `dry_run_behavior` takes an `Existing_File_Behavior` and returns a
       transformed one that is supposed to be applied on a dry run file if it
       already exists (since the dry run file often needs to be treated
       differently than the original file).
    Value write_overwriting write_appending write_raising_error write_backing_up dry_run_behavior

    ## PRIVATE
       Writes to a file according to the provided existing file behaviour.
       This variant does not handle dry run logic.
       It will most likely fail at `with_output_stream` if the output context is
       not enabled. It may be used if the caller has custom handling for dry run
       and calls this method within `Context.Output.with_enabled`.
    write self file existing_file_behavior action =
        case existing_file_behavior of
            Existing_File_Behavior.Overwrite -> self.write_overwriting file action
            Existing_File_Behavior.Backup -> self.write_backing_up file action
            Existing_File_Behavior.Append -> self.write_appending file action
            Existing_File_Behavior.Error -> self.write_raising_error file action

    ## PRIVATE
       Writes to a file, relying on
    write_handling_dry_run

## PRIVATE
default_overwrite file action =
    file.with_output_stream [File_Access.Write, File_Access.Create, File_Access.Truncate_Existing] action

## PRIVATE
default_append file action =
    file.with_output_stream [File_Access.Write, File_Access.Create, File_Access.Append] action

## PRIVATE
default_raise_error file action =
    file.with_output_stream [File_Access.Write, File_Access.Create_New] action

## PRIVATE
   A `Backup` strategy that does the following:
   1. First, write to a temporary file.
     i. If the write fails, do nothing more. The original file is kept intact.
     ii. If the write succeeds, we move the original file (if it exists) to a
         backup location, and then move the temporary new file to the target location.

   This strategy assumes that the `move` operation on a single filesystem is
   cheap (it is a rename), and is optimized for that case.
moving_backup file action = recover_io_and_not_found <|
    parent = file.parent
    bak_file = parent / file.name+".bak"
    # The loop is looking for a name for a temporary file that is not yet taken.
    go i =
        new_name = file.name + ".new" + if i == 0 then "" else "." + i.to_text
        new_file = parent / new_name
        handle_existing_file _ = go i+1
        handle_write_failure_panic panic =
            ## Since we were already inside of the write operation,
               the file must have been created, but since we failed, we need to clean it up.
            new_file.delete
            Panic.throw panic.payload.cause
        handle_write_failure_dataflow caught_panic =
            ## Since we were already inside of the write operation,
               the file must have been created, but since we failed, we need to clean it up.
            new_file.delete
            Error.throw caught_panic.payload.cause
        handle_file_already_exists = catch_already_exists handle_existing_file
        handle_internal_dataflow = Panic.catch Internal_Write_Operation_Errored handler=handle_write_failure_dataflow
        handle_internal_panic = Panic.catch Internal_Write_Operation_Panicked handler=handle_write_failure_panic
        handle_file_already_exists <| handle_internal_dataflow <| handle_internal_panic <|

            ## First we write the temporary file, handling any failures.
               If the write fails, we'll do nothing more.
            result = Panic.rethrow <|
                new_file.with_output_stream [File_Access.Write, File_Access.Create_New] output_stream->
                    result = Panic.catch Any (action output_stream) caught_panic->
                        Panic.throw (Internal_Write_Operation_Panicked.Panic caught_panic)
                    result.catch Any dataflow_error->
                        Panic.throw (Internal_Write_Operation_Errored.Error dataflow_error)

            ## After successful write to a temp file, we move the original file
               to the backup location.
               We ignore the file not found error, because it means that there
               is no file to back-up. This may also be caused by someone
               removing the original file during the time when we have been
               writing the new one to the temporary location. There is nothing
               to back-up anymore, but this is not a failure, so it can be
               safely ignored.
            not_found_handler caught_panic = case caught_panic.payload of
                File_Error.Not_Found _ -> Nothing
                _ -> Panic.throw caught_panic
            Panic.catch File_Error handler=not_found_handler <|
                Panic.rethrow <| file.move_to bak_file replace_existing=True

            ## Lastly, we move the temporary new file to the destination, and
               return the result.
            Panic.rethrow <| new_file.move_to file
            result

## PRIVATE
type Dry_Run_File_Settings
    ## PRIVATE
       Arguments:
       - existing_file_behavior: Specifies how to treat an existing dry run file.
         Usually, `Overwrite` is used regardless of the original setting.
         The exception is `Append`, which usually requires to copy the original
         file first to keep the state consistent.
       - copy_original: Specifies whether to copy the original file to the dry
         run file before writing. If the file is not copied, contents from a
         previous dry run may still be there, so any options other than
         `Overwrite` may be risky.
    Value existing_file_behavior:Existing_File_Behavior copy_original:Boolean

## PRIVATE
default_dry_run_behavior file behavior:Existing_File_Behavior -> Dry_Run_Behavior = case behavior of
    Existing_File_Behavior.Error ->
        ## In case the _original_ file exists, the dry run will raise error because the actual write would have errored.
           If the original file does not exist, we can just overwrite the dry run file.
        if file.exists then Error.throw (File_Error.Already_Exists file) else
            Dry_Run_File_Settings.Value Existing_File_Behavior.Overwrite copy_original=False
    Existing_File_Behavior.Backup ->
        Dry_Run_File_Settings.Value Existing_File_Behavior.Overwrite copy_original=False
    Existing_File_Behavior.Overwrite ->
        Dry_Run_File_Settings.Value Existing_File_Behavior.Overwrite copy_original=False
    Existing_File_Behavior.Append ->
        Dry_Run_File_Settings.Value Existing_File_Behavior.Append copy_original=True

type Dry_Run_Strategy
    ## PRIVATE
       This strategy
    Not_Allowed
